#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: notebook.ipynb
import random
import traceback

import signal
import time

from isolation import Board, game_as_text
# Credits if any
# 1) Signal Library (used in score() method): https://docs.python.org/2/library/signal.html
# 2)
# 3)
from test_players import RandomPlayer


################################################
class OpenMoveEvalFn:
    def score(self, game, my_player=None):
        active_player = game.get_active_player()
        inactive_player = game.get_inactive_player()

        active_player_moves = game.get_player_moves(active_player)
        inactive_player_moves = game.get_player_moves(inactive_player)
        return len(active_player_moves) - len(inactive_player_moves)


class CustomEvalFn:
    def score(self, game, my_player=None):
        active_player = game.get_active_player()
        inactive_player = game.get_inactive_player()

        active_player_moves = game.get_player_moves(active_player)
        inactive_player_moves = game.get_player_moves(inactive_player)

        if not active_player_moves and active_player == my_player:
            # I lost
            return len(active_player_moves) - 2 * len(inactive_player_moves)
        elif not active_player_moves and active_player != my_player:
            # I won
            return 2 * len(active_player_moves) - len(inactive_player_moves)
        elif not inactive_player_moves and active_player == my_player:
            # I won
            return 2 * len(active_player_moves) - len(inactive_player_moves)
        elif not inactive_player_moves and active_player != my_player:
            # I lost
            return len(active_player_moves) - 2 * len(inactive_player_moves)

        return len(active_player_moves) - len(inactive_player_moves)


class ABPlayerO:
    def __init__(self, search_depth=3, eval_fn=OpenMoveEvalFn(), name="ABPlayerO"):
        self.eval_fn = eval_fn
        self.search_depth = search_depth
        self.name = name

    def move(self, game, time_left):
        signal.signal(signal.SIGALRM, self.handler_timeout)
        signal.setitimer(0, ((time_left() / 1000) - 0.01), 0.01)
        if not game.get_player_moves(self):
            return None
        else:
            best_move = None
            try:
                start_time = int(round(time.time() * 1000))
                while time_left() - (int(round(time.time() * 1000)) - start_time):
                    for depth in range(2, 100, 2):
                        best_move, utility = alphabeta(self, game, time_left, depth=depth)
            except Exception:
                signal.alarm(0)
                return best_move

    def utility(self, game, my_turn):
        return self.eval_fn.score(game, self)

    def handler_timeout(self):
        raise TimeoutError


def minimax(player, game, time_left, depth, my_turn=True, current_depth=0, depth_dict={}, move=None):
    global final_score
    if current_depth == depth or not game.get_active_moves():
        return OpenMoveEvalFn().score(game, player)

    current_moves = game.get_active_moves()
    score_list = []
    for move in current_moves:
        new_board, is_over, winner = game.forecast_move(move)
        if my_turn:
            ret_val = minimax(player, new_board, time_left, depth, False, current_depth + 1, move)
            if type(ret_val) != int:
                ret_val = ret_val[1]
            score_list.append((move, ret_val))
            move, final_score = sorted(score_list, key=lambda x: x[1], reverse=True)[0]
        else:
            ret_val = minimax(player, new_board, time_left, depth, True, current_depth + 1, move)
            if type(ret_val) != int:
                ret_val = ret_val[1]
            score_list.append((move, ret_val))
            move, final_score = sorted(score_list, key=lambda x: x[1], reverse=False)[0]
    return move, final_score


################################################


class ABPlayerN:
    def __init__(self, search_depth=3, eval_fn=CustomEvalFn(), name="ABPlayerN"):
        self.eval_fn = eval_fn
        self.search_depth = search_depth
        self.name = name

    def move(self, game, time_left):
        signal.signal(signal.SIGALRM, self.handler_timeout)
        signal.setitimer(0, ((time_left() / 1000) - 0.01), 0.01)
        if not game.get_player_moves(self):
            return None
        else:
            best_move = None
            depth = None
            while True:
                try:
                    for depth in range(2, 100, 2):
                        best_move, utility = alphabeta(self, game, time_left, depth=depth)
                        print("Depth : {}, Best Move: {} ,Score: {}".format(depth, best_move, utility))
                    return best_move
                except Exception:
                    print("Reached depth of {}".format(depth))
                    print(best_move)
                    signal.alarm(0)
                    return best_move

    def utility(self, game, my_turn=True):
        return self.eval_fn.score(game, self)

    def handler_timeout(self):
        raise TimeoutError


def alphabeta(player, game, time_left, depth, alpha=float("-inf"), beta=float("inf"), my_turn=True, current_depth=0):
    current_moves = game.get_active_moves()
    if current_depth == depth or not current_moves:
        return OpenMoveEvalFn().score(game, player)

    score_list = []
    if my_turn:
        for move in current_moves:
            new_board, is_over, winner = game.forecast_move(move)
            ret_val = alphabeta(player, new_board, time_left, depth, alpha, beta, False, current_depth + 1)
            if type(ret_val) != int:
                ret_val = ret_val[1]
            score_list.append((move, ret_val))
            final_move, final_score = sorted(score_list, key=lambda x: x[1], reverse=True)[0]
            if final_score >= beta:
                break
            alpha = max(alpha, final_score)
        return final_move, final_score

    else:
        current_moves = game.get_active_moves()
        for move in current_moves:
            new_board, is_over, winner = game.forecast_move(move)
            ret_val = alphabeta(player, new_board, time_left, depth, alpha, beta, True, current_depth + 1)
            if type(ret_val) != int:
                ret_val = ret_val[1]
            score_list.append((move, ret_val))

            final_move, final_score = sorted(score_list, key=lambda x: x[1], reverse=False)[0]
            if final_score <= alpha:
                break
            beta = min(beta, final_score)
        return final_move, final_score


################################################
######################################################################
############ DON'T WRITE ANY CODE OUTSIDE THE CLASS! #################
######## IF YOU WANT TO CALL OR TEST IT CREATE A NEW CELL ############
######################################################################
# 1. TODO: Beat MMPlayer all the time - ABPlayerNew
# 2. TODO: Beat new ABPlayer (By adding killer heuristics)
# 3. TODO: Make sure that new ABPLayer beats everyone else in the game

if __name__ == '__main__':
    winnings = 0
    losses = 0
    errors_not_implemented = 0
    errors_others = 0
    others = 0
    games = 10
    for i in range(0, games):
        print("Playing the game: {} iteration".format(i))
        try:
            p = RandomPlayer()
            q = ABPlayerO()
            r = ABPlayerN()
            c = [q, r]
            random.shuffle(c)
            game = Board(c[0], c[1], 7, 7)
            output_b = game.copy()
            winner, move_history, termination = game.play_isolation(time_limit=1000, print_moves=False)
            print("\n", winner, " has won. Reason: ", termination)
            if "ABPlayerN" in winner:
                winnings += 1
            else:
                losses += 1
                print(game_as_text(winner, move_history, termination, output_b))
            # Uncomment to see game
            # print(game_as_text(winner, move_history, termination, output_b))
        except NotImplementedError:
            print('CustomPlayer Test: Not Implemented')
            errors_not_implemented += 1
        except:
            errors_others += 1
            print('CustomPlayer Test: ERROR OCCURRED')
            print(traceback.format_exc())

    print("\n\n\n\n")
    print("Total Games: {}".format(len(range(0, games))))
    print("Winnings ABPlayerN: {}".format(winnings))
    print("Winnings ABPlayerO: {}".format(losses))
    print("Not determined: {}".format(others))
    print("Not Implemented Errors: {}".format(errors_not_implemented))
    print("Other Errors: {}".format(errors_others))
